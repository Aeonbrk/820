# Idea Summary

## Wandao`s questions

1. **1DelAllX.cpp** - 删除所有值为x的元素：
   - 思路：遍历单链表，使用两个指针（一个当前节点，一个前驱节点）来删除值为x的节点。
   - 时间复杂度：O(n)，其中n是链表的长度。
   - 空间复杂度：O(1)，不包括链表本身的存储。

2. **2DelMin.cpp** - 删除最小值节点：
   - 思路：遍历单链表找到最小值节点，然后删除该节点。
   - 时间复杂度：O(n)，其中n是链表的长度。
   - 空间复杂度：O(1)，不包括链表本身的存储。
3. **3Reverse.cpp** - 逆置单链表：
   - 思路：使用三个指针（前一个节点、当前节点、下一个节点）来逆置链表。
   - 时间复杂度：O(n)，其中n是链表的长度。
   - 空间复杂度：O(1)，不包括链表本身的存储。

4. **4DeleteRange.cpp** - 删除指定范围内的元素：
   - 思路：遍历单链表，检查每个节点的数据值是否在给定的两个值之间，如果是，则删除该节点。
   - 时间复杂度：O(n)，其中n是链表的长度。
   - 空间复杂度：O(1)，不包括链表本身的存储。

5. **5PublicNode.md** - 寻找两个链表的公共节点：
   - 思路：提供了四种算法思想（双指针法、哈希表法、栈法、拼接法）来找到两个链表的公共节点。
   - 时间复杂度：O(n)（对于双指针法和拼接法），O(n^2)（对于哈希表法和栈法）。
   - 空间复杂度：O(1)（对于双指针法和拼接法），O(n)（对于哈希表法和栈法）。

6. **6SplitList.cpp** - 拆分线性表：
   - 思路：遍历单链表，根据索引奇偶性将元素分配到两个不同的链表中。
   - 时间复杂度：O(n)，其中n是链表的长度。
   - 空间复杂度：O(1)，不包括新链表本身的存储。

7. **7DeleteDuplicate.cpp** - 删除链表中的重复元素：
   - **思路**：遍历递增有序的单链表，使用两个指针 current 和 prev。当 current 和 prev 的数据相同时，删除 current；否则，继续移动指针，直到遍历完链表。
   - **时间复杂度**：O(n)，其中 n 是链表的长度。每个节点只被遍历一次。
   - **空间复杂度**：O(1)，只使用了几个指针变量，不需要额外的空间（不包括删除操作带来的内存释放）。

8. **8FindPublicAndCombine.cpp** - 在两个链表中寻找公共元素并将其组合：
   - **思路**：使用双指针法遍历两个带头节点的递增有序链表 `A` 和 `B`。当发现公共节点时，将该节点插入到新链表 `C` 中，而不破坏原链表。改进使用尾插法来优化插入操作。
   - **时间复杂度**：O(n)，其中 n 是链表的长度，因为每个节点最多只访问一次。
   - **空间复杂度**：O(1)，除去存储结果链表外，不使用额外的空间。

9. **9FindPublic_V2.cpp** - 求链表交集并存入 `A` 链表：
   - **思路**：双指针法遍历两个递增有序的链表 `A` 和 `B`，当 `A` 中的元素不属于交集时，将该元素删除，使 `A` 最终存储交集。操作时只修改 `A`，不改变 `B`。
   - **时间复杂度**：O(n)，每个节点最多访问一次。
   - **空间复杂度**：O(1)，仅使用少量指针，不需要额外的空间。

10. **IsSymmetry.cpp** - 判断循环双链表是否对称：
    - **思路**：利用两个指针分别从链表的头节点和尾节点开始，向内遍历，依次比较节点数据。当两个指针相遇或错过时停止遍历。若发现不对称的元素，返回 `false`，否则返回 `true`。
    - **时间复杂度**：O(n)，其中 n 是链表的长度，每个节点最多访问一次。
    - **空间复杂度**：O(1)，仅使用少量指针，无需额外空间。

11. **Combine.cpp** - 将两个循环单链表连接成一个循环链表：
    - **思路**：首先找到两个链表的尾节点，将第一个链表的尾节点指向第二个链表的头节点，再将第二个链表的尾节点指向第一个链表的头节点，保证合并后的链表仍为循环链表。
    - **时间复杂度**：O(n)，其中 n 是链表的长度，需要遍历两个链表以找到尾节点。
    - **空间复杂度**：O(1)，只使用指针，无额外空间开销。
